(self.webpackChunkdashboard_widgets=self.webpackChunkdashboard_widgets||[]).push([[335],{5335:(A,c,f)=>{f.r(c),f.d(c,{HttpClientTestingModule:()=>y,HttpTestingController:()=>h,TestRequest:()=>d});var i=f(4855),a=f(8230),g=f(824);class h{}class d{constructor(n,e){this.request=n,this.observer=e,this._cancelled=!1}get cancelled(){return this._cancelled}flush(n,e={}){if(this.cancelled)throw new Error("Cannot flush a cancelled request.");const r=this.request.urlWithParams,s=e.headers instanceof i.HttpHeaders?e.headers:new i.HttpHeaders(e.headers);n=function v(t,n){if(null===n)return null;switch(t){case"arraybuffer":return function E(t){if(typeof ArrayBuffer>"u")throw new Error("ArrayBuffer responses are not supported on this platform.");if(t instanceof ArrayBuffer)return t;throw new Error("Automatic conversion to ArrayBuffer is not supported for response type.")}(n);case"blob":return function B(t){if(typeof Blob>"u")throw new Error("Blob responses are not supported on this platform.");if(t instanceof Blob)return t;if(ArrayBuffer&&t instanceof ArrayBuffer)return new Blob([t]);throw new Error("Automatic conversion to Blob is not supported for response type.")}(n);case"json":return p(n);case"text":return function m(t){if("string"==typeof t)return t;if(typeof ArrayBuffer<"u"&&t instanceof ArrayBuffer)throw new Error("Automatic conversion to text is not supported for ArrayBuffers.");if(typeof Blob<"u"&&t instanceof Blob)throw new Error("Automatic conversion to text is not supported for Blobs.");return JSON.stringify(p(t,"text"))}(n);default:throw new Error(`Unsupported responseType: ${t}`)}}(this.request.responseType,n);let o=e.statusText,u=void 0!==e.status?e.status:200;if(void 0===e.status&&(null===n?(u=204,o=o||"No Content"):o=o||"OK"),void 0===o)throw new Error("statusText is required when setting a custom status.");u>=200&&u<300?(this.observer.next(new i.HttpResponse({body:n,headers:s,status:u,statusText:o,url:r})),this.observer.complete()):this.observer.error(new i.HttpErrorResponse({error:n,headers:s,status:u,statusText:o,url:r}))}error(n,e={}){if(this.cancelled)throw new Error("Cannot return an error for a cancelled request.");if(e.status&&e.status>=200&&e.status<300)throw new Error("error() called with a successful status.");const r=e.headers instanceof i.HttpHeaders?e.headers:new i.HttpHeaders(e.headers);this.observer.error(new i.HttpErrorResponse({error:n,headers:r,status:e.status||0,statusText:e.statusText||"",url:this.request.urlWithParams}))}event(n){if(this.cancelled)throw new Error("Cannot send events to a cancelled request.");this.observer.next(n)}}function p(t,n="JSON"){if(typeof ArrayBuffer<"u"&&t instanceof ArrayBuffer)throw new Error(`Automatic conversion to ${n} is not supported for ArrayBuffers.`);if(typeof Blob<"u"&&t instanceof Blob)throw new Error(`Automatic conversion to ${n} is not supported for Blobs.`);if("string"==typeof t||"number"==typeof t||"object"==typeof t||"boolean"==typeof t||Array.isArray(t))return t;throw new Error(`Automatic conversion to ${n} is not supported for response type.`)}let l=(()=>{class t{constructor(){this.open=[]}handle(e){return new g.Observable(r=>{const s=new d(e,r);return this.open.push(s),r.next({type:i.HttpEventType.Sent}),()=>{s._cancelled=!0}})}_match(e){return this.open.filter("string"==typeof e?r=>r.request.urlWithParams===e:"function"==typeof e?r=>e(r.request):r=>!(e.method&&r.request.method!==e.method.toUpperCase()||e.url&&r.request.urlWithParams!==e.url))}match(e){const r=this._match(e);return r.forEach(s=>{const o=this.open.indexOf(s);-1!==o&&this.open.splice(o,1)}),r}expectOne(e,r){r=r||this.descriptionFromMatcher(e);const s=this.match(e);if(s.length>1)throw new Error(`Expected one matching request for criteria "${r}", found ${s.length} requests.`);if(0===s.length){let o=`Expected one matching request for criteria "${r}", found none.`;throw this.open.length>0&&(o+=` Requests received are: ${this.open.map(w).join(", ")}.`),new Error(o)}return s[0]}expectNone(e,r){r=r||this.descriptionFromMatcher(e);const s=this.match(e);if(s.length>0)throw new Error(`Expected zero matching requests for criteria "${r}", found ${s.length}.`)}verify(e={}){let r=this.open;if(e.ignoreCancelled&&(r=r.filter(s=>!s.cancelled)),r.length>0){const s=r.map(w).join(", ");throw new Error(`Expected no open requests, found ${r.length}: ${s}`)}}descriptionFromMatcher(e){return"string"==typeof e?`Match URL: ${e}`:"object"==typeof e?`Match method: ${e.method||"(any)"}, URL: ${e.url||"(any)"}`:`Match by function: ${e.name}`}}return t.\u0275fac=function(e){return new(e||t)},t.\u0275prov=a.\u0275\u0275defineInjectable({token:t,factory:t.\u0275fac}),t})();function w(t){return`${t.request.method} ${t.request.urlWithParams}`}let y=(()=>{class t{}return t.\u0275fac=function(e){return new(e||t)},t.\u0275mod=a.\u0275\u0275defineNgModule({type:t}),t.\u0275inj=a.\u0275\u0275defineInjector({providers:[l,{provide:i.HttpBackend,useExisting:l},{provide:h,useExisting:l}],imports:[[i.HttpClientModule]]}),t})()}}]);