(self.webpackChunkdashboard_widgets=self.webpackChunkdashboard_widgets||[]).push([[466],{1930:(Ne,A,O)=>{function j(o,e,t,s,r,i,l){try{var c=o[i](l),a=c.value}catch(f){return void t(f)}c.done?e(a):Promise.resolve(a).then(s,r)}function w(o){return function(){var e=this,t=arguments;return new Promise(function(s,r){var i=o.apply(e,t);function l(a){j(i,s,r,l,c,"next",a)}function c(a){j(i,s,r,l,c,"throw",a)}l(void 0)})}}O.r(A),O.d(A,{ComponentFixture:()=>I,ComponentFixtureAutoDetect:()=>W,ComponentFixtureNoNgZone:()=>$,InjectSetupWrapper:()=>H,TestBed:()=>F,TestComponentRenderer:()=>N,__core_private_testing_placeholder__:()=>be,async:()=>X,discardPeriodicTasks:()=>oe,fakeAsync:()=>te,flush:()=>re,flushMicrotasks:()=>ie,getTestBed:()=>C,inject:()=>J,resetFakeAsyncZone:()=>x,tick:()=>se,waitForAsync:()=>k,withModule:()=>Re,\u0275MetadataOverrider:()=>G});var n=O(8230),Y=O(8661);function k(o){const e=typeof Zone<"u"?Zone:null;if(!e)return function(){return Promise.reject("Zone is needed for the waitForAsync() test helper but could not be found. Please make sure that your environment includes zone.js")};const t=e&&e[e.__symbol__("asyncTest")];return"function"==typeof t?t(o):function(){return Promise.reject("zone-testing.js is needed for the async() test helper but could not be found. Please make sure that your environment includes zone.js/testing")}}function X(o){return k(o)}class I{constructor(e,t,s){this.componentRef=e,this.ngZone=t,this._autoDetect=s,this._isStable=!0,this._isDestroyed=!1,this._resolve=null,this._promise=null,this._onUnstableSubscription=null,this._onStableSubscription=null,this._onMicrotaskEmptySubscription=null,this._onErrorSubscription=null,this.changeDetectorRef=e.changeDetectorRef,this.elementRef=e.location,this.debugElement=(0,n.getDebugNode)(this.elementRef.nativeElement),this.componentInstance=e.instance,this.nativeElement=this.elementRef.nativeElement,this.componentRef=e,this.ngZone=t,t&&t.runOutsideAngular(()=>{this._onUnstableSubscription=t.onUnstable.subscribe({next:()=>{this._isStable=!1}}),this._onMicrotaskEmptySubscription=t.onMicrotaskEmpty.subscribe({next:()=>{this._autoDetect&&this.detectChanges(!0)}}),this._onStableSubscription=t.onStable.subscribe({next:()=>{this._isStable=!0,null!==this._promise&&function ee(o){Zone.current.scheduleMicroTask("scheduleMicrotask",o)}(()=>{t.hasPendingMacrotasks||null!==this._promise&&(this._resolve(!0),this._resolve=null,this._promise=null)})}}),this._onErrorSubscription=t.onError.subscribe({next:r=>{throw r}})})}_tick(e){this.changeDetectorRef.detectChanges(),e&&this.checkNoChanges()}detectChanges(e=!0){null!=this.ngZone?this.ngZone.run(()=>{this._tick(e)}):this._tick(e)}checkNoChanges(){this.changeDetectorRef.checkNoChanges()}autoDetectChanges(e=!0){if(null==this.ngZone)throw new Error("Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set");this._autoDetect=e,this.detectChanges()}isStable(){return this._isStable&&!this.ngZone.hasPendingMacrotasks}whenStable(){return this.isStable()?Promise.resolve(!1):(null!==this._promise||(this._promise=new Promise(e=>{this._resolve=e})),this._promise)}_getRenderer(){return void 0===this._renderer&&(this._renderer=this.componentRef.injector.get(n.RendererFactory2,null)),this._renderer}whenRenderingDone(){const e=this._getRenderer();return e&&e.whenRenderingDone?e.whenRenderingDone():this.whenStable()}destroy(){this._isDestroyed||(this.componentRef.destroy(),null!=this._onUnstableSubscription&&(this._onUnstableSubscription.unsubscribe(),this._onUnstableSubscription=null),null!=this._onStableSubscription&&(this._onStableSubscription.unsubscribe(),this._onStableSubscription=null),null!=this._onMicrotaskEmptySubscription&&(this._onMicrotaskEmptySubscription.unsubscribe(),this._onMicrotaskEmptySubscription=null),null!=this._onErrorSubscription&&(this._onErrorSubscription.unsubscribe(),this._onErrorSubscription=null),this._isDestroyed=!0)}}const P=typeof Zone<"u"?Zone:null,h=P&&P[P.__symbol__("fakeAsyncTest")],v="zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing";function x(){if(h)return h.resetFakeAsyncZone();throw new Error(v)}function te(o){if(h)return h.fakeAsync(o);throw new Error(v)}function se(o=0,e={processNewMacroTasksSynchronously:!0}){if(h)return h.tick(o,e);throw new Error(v)}function re(o){if(h)return h.flush(o);throw new Error(v)}function oe(){if(h)return h.discardPeriodicTasks();throw new Error(v)}function ie(){if(h)return h.flushMicrotasks();throw new Error(v)}let m=new Map;const y=new Set;function S(o){return y.has(o)}function U(){const o=m;return m=new Map,o}function ue(o){return"string"==typeof o?o:o.text()}let ae=0;class G{constructor(){this._references=new Map}overrideMetadata(e,t,s){const r={};if(t&&function me(o){const e=[];Object.keys(o).forEach(s=>{s.startsWith("_")||e.push(s)});let t=o;for(;t=Object.getPrototypeOf(t);)Object.keys(t).forEach(s=>{const r=Object.getOwnPropertyDescriptor(t,s);!s.startsWith("_")&&r&&"get"in r&&e.push(s)});return e}(t).forEach(i=>r[i]=t[i]),s.set){if(s.remove||s.add)throw new Error(`Cannot set and add/remove ${(0,n.\u0275stringify)(e)} at the same time!`);!function fe(o,e){for(const t in e)o[t]=e[t]}(r,s.set)}return s.remove&&function he(o,e,t){const s=new Set;for(const r in e){const i=e[r];Array.isArray(i)?i.forEach(l=>{s.add(E(r,l,t))}):s.add(E(r,i,t))}for(const r in o){const i=o[r];Array.isArray(i)?o[r]=i.filter(l=>!s.has(E(r,l,t))):s.has(E(r,i,t))&&(o[r]=void 0)}}(r,s.remove,this._references),s.add&&function pe(o,e){for(const t in e){const s=e[t],r=o[t];o[t]=null!=r&&Array.isArray(r)?r.concat(s):s}}(r,s.add),new e(r)}}function E(o,e,t){let s=0;const r=new Map;return`${o}:${JSON.stringify(e,(l,c)=>null!==c&&"object"==typeof c?r.has(c)?r.get(c):(r.set(c,"\u0275obj#"+s++),c):("function"==typeof c&&(c=function ve(o,e){let t=e.get(o);return t||(t=`${(0,n.\u0275stringify)(o)}${ae++}`,e.set(o,t)),t}(c,t)),c))}`}const ge=new n.\u0275ReflectionCapabilities;class T{constructor(){this.overrides=new Map,this.resolved=new Map}addOverride(e,t){const s=this.overrides.get(e)||[];s.push(t),this.overrides.set(e,s),this.resolved.delete(e)}setOverrides(e){this.overrides.clear(),e.forEach(([t,s])=>{this.addOverride(t,s)})}getAnnotation(e){const t=ge.annotations(e);for(let s=t.length-1;s>=0;s--){const r=t[s];if(r instanceof n.Directive||r instanceof n.Component||r instanceof n.Pipe||r instanceof n.NgModule)return r instanceof this.type?r:null}return null}resolve(e){let t=this.resolved.get(e)||null;if(!t){if(t=this.getAnnotation(e),t){const s=this.overrides.get(e);if(s){const r=new G;s.forEach(i=>{t=r.overrideMetadata(this.type,t,i)})}}this.resolved.set(e,t)}return t}}class Me extends T{get type(){return n.Directive}}class ye extends T{get type(){return n.Component}}class _e extends T{get type(){return n.Pipe}}class Oe extends T{get type(){return n.NgModule}}var p=(()=>((p=p||{})[p.DECLARATION=0]="DECLARATION",p[p.OVERRIDE_TEMPLATE=1]="OVERRIDE_TEMPLATE",p))();class L{constructor(e,t){this.platform=e,this.additionalModuleTypes=t,this.originalComponentResolutionQueue=null,this.declarations=[],this.imports=[],this.providers=[],this.schemas=[],this.pendingComponents=new Set,this.pendingDirectives=new Set,this.pendingPipes=new Set,this.seenComponents=new Set,this.seenDirectives=new Set,this.overriddenModules=new Set,this.existingComponentStyles=new Map,this.resolvers=function Ee(){return{module:new Oe,component:new ye,directive:new Me,pipe:new _e}}(),this.componentToModuleScope=new Map,this.initialNgDefs=new Map,this.defCleanupOps=[],this._injector=null,this.compilerProviders=null,this.providerOverrides=[],this.rootProviderOverrides=[],this.providerOverridesByModule=new Map,this.providerOverridesByToken=new Map,this.moduleProvidersOverridden=new Set,this.testModuleRef=null,this.testModuleType=class s{}}setCompilerProviders(e){this.compilerProviders=e,this._injector=null}configureTestingModule(e){void 0!==e.declarations&&(this.queueTypeArray(e.declarations,p.DECLARATION),this.declarations.push(...e.declarations)),void 0!==e.imports&&(this.queueTypesFromModulesArray(e.imports),this.imports.push(...e.imports)),void 0!==e.providers&&this.providers.push(...e.providers),void 0!==e.schemas&&this.schemas.push(...e.schemas)}overrideModule(e,t){this.overriddenModules.add(e),this.resolvers.module.addOverride(e,t);const s=this.resolvers.module.resolve(e);if(null===s)throw D(e.name,"NgModule");this.recompileNgModule(e,s),this.queueTypesFromModulesArray([e])}overrideComponent(e,t){this.resolvers.component.addOverride(e,t),this.pendingComponents.add(e)}overrideDirective(e,t){this.resolvers.directive.addOverride(e,t),this.pendingDirectives.add(e)}overridePipe(e,t){this.resolvers.pipe.addOverride(e,t),this.pendingPipes.add(e)}overrideProvider(e,t){let s;s=void 0!==t.useFactory?{provide:e,useFactory:t.useFactory,deps:t.deps||[],multi:t.multi}:void 0!==t.useValue?{provide:e,useValue:t.useValue,multi:t.multi}:{provide:e};const r="string"!=typeof e?(0,n.\u0275getInjectableDef)(e):null,i=null===r?null:(0,n.resolveForwardRef)(r.providedIn);if(("root"===i?this.rootProviderOverrides:this.providerOverrides).push(s),this.providerOverridesByToken.set(e,s),null!==r&&null!==i&&"string"!=typeof i){const c=this.providerOverridesByModule.get(i);void 0!==c?c.push(s):this.providerOverridesByModule.set(i,[s])}}overrideTemplateUsingTestingModule(e,t){const s=e[n.\u0275NG_COMP_DEF],i=!!s&&!S(e)&&(()=>{const c=this.resolvers.component.resolve(e);return!!c.styleUrls&&c.styleUrls.length>0})();this.overrideComponent(e,{set:i?{template:t,styles:[],styleUrls:[]}:{template:t}}),i&&s.styles&&s.styles.length>0&&this.existingComponentStyles.set(e,s.styles),this.componentToModuleScope.set(e,p.OVERRIDE_TEMPLATE)}compileComponents(){var e=this;return w(function*(){if(e.clearComponentResolutionQueue(),e.compileTypesSync()){let s;yield function ne(o){const e=[],t=new Map;function s(r){let i=t.get(r);if(!i){const l=o(r);t.set(r,i=l.then(ue))}return i}return m.forEach((r,i)=>{const l=[];r.templateUrl&&l.push(s(r.templateUrl).then(M=>{r.template=M}));const c=r.styleUrls,a=r.styles||(r.styles=[]),f=r.styles.length;c&&c.forEach((M,Pe)=>{a.push(""),l.push(s(M).then(Se=>{a[f+Pe]=Se,c.splice(c.indexOf(M),1),0==c.length&&(r.styleUrls=void 0)}))});const b=Promise.all(l).then(()=>function de(o){y.delete(o)}(i));e.push(b)}),U(),Promise.all(e).then(()=>{})}(i=>(s||(s=e.injector.get(Y.ResourceLoader)),Promise.resolve(s.get(i))))}})()}finalize(){this.compileTypesSync(),this.compileTestModule(),this.applyTransitiveScopes(),this.applyProviderOverrides(),this.patchComponentsWithExistingStyles(),this.componentToModuleScope.clear(),this.testModuleRef=new n.\u0275Render3NgModuleRef(this.testModuleType,this.platform.injector),this.testModuleRef.injector.get(n.ApplicationInitStatus).runInitializers();const t=this.testModuleRef.injector.get(n.LOCALE_ID,n.\u0275DEFAULT_LOCALE_ID);return(0,n.\u0275setLocaleId)(t),this.testModuleRef}_compileNgModuleSync(e){this.queueTypesFromModulesArray([e]),this.compileTypesSync(),this.applyProviderOverrides(),this.applyProviderOverridesToModule(e),this.applyTransitiveScopes()}_compileNgModuleAsync(e){var t=this;return w(function*(){t.queueTypesFromModulesArray([e]),yield t.compileComponents(),t.applyProviderOverrides(),t.applyProviderOverridesToModule(e),t.applyTransitiveScopes()})()}_getModuleResolver(){return this.resolvers.module}_getComponentFactories(e){return g(e.\u0275mod.declarations).reduce((t,s)=>{const r=s.\u0275cmp;return r&&t.push(new n.\u0275Render3ComponentFactory(r,this.testModuleRef)),t},[])}compileTypesSync(){let e=!1;return this.pendingComponents.forEach(t=>{e=e||S(t);const s=this.resolvers.component.resolve(t);if(null===s)throw D(t.name,"Component");this.maybeStoreNgDef(n.\u0275NG_COMP_DEF,t),(0,n.\u0275compileComponent)(t,s)}),this.pendingComponents.clear(),this.pendingDirectives.forEach(t=>{const s=this.resolvers.directive.resolve(t);if(null===s)throw D(t.name,"Directive");this.maybeStoreNgDef(n.\u0275NG_DIR_DEF,t),(0,n.\u0275compileDirective)(t,s)}),this.pendingDirectives.clear(),this.pendingPipes.forEach(t=>{const s=this.resolvers.pipe.resolve(t);if(null===s)throw D(t.name,"Pipe");this.maybeStoreNgDef(n.\u0275NG_PIPE_DEF,t),(0,n.\u0275compilePipe)(t,s)}),this.pendingPipes.clear(),e}applyTransitiveScopes(){if(this.overriddenModules.size>0){const r=this.collectModulesAffectedByOverrides(this.testModuleType[n.\u0275NG_MOD_DEF].imports);r.size>0&&r.forEach(i=>{this.storeFieldOfDefOnType(i,n.\u0275NG_MOD_DEF,"transitiveCompileScopes"),i[n.\u0275NG_MOD_DEF].transitiveCompileScopes=null})}const e=new Map,t=s=>{if(!e.has(s)){const i=function we(o){return o===p.DECLARATION||o===p.OVERRIDE_TEMPLATE}(s)?this.testModuleType:s;e.set(s,(0,n.\u0275transitiveScopesFor)(i))}return e.get(s)};this.componentToModuleScope.forEach((s,r)=>{const i=t(s);this.storeFieldOfDefOnType(r,n.\u0275NG_COMP_DEF,"directiveDefs"),this.storeFieldOfDefOnType(r,n.\u0275NG_COMP_DEF,"pipeDefs"),this.storeFieldOfDefOnType(r,n.\u0275NG_COMP_DEF,"tView"),(0,n.\u0275patchComponentDefWithScope)(r.\u0275cmp,i)}),this.componentToModuleScope.clear()}applyProviderOverrides(){const e=t=>s=>{const i=(t===n.\u0275NG_COMP_DEF?this.resolvers.component:this.resolvers.directive).resolve(s);this.hasProviderOverrides(i.providers)&&this.patchDefWithProviderOverrides(s,t)};this.seenComponents.forEach(e(n.\u0275NG_COMP_DEF)),this.seenDirectives.forEach(e(n.\u0275NG_DIR_DEF)),this.seenComponents.clear(),this.seenDirectives.clear()}applyProviderOverridesToModule(e){if(this.moduleProvidersOverridden.has(e))return;this.moduleProvidersOverridden.add(e);const t=e[n.\u0275NG_INJ_DEF];if(this.providerOverridesByToken.size>0){const s=[...t.providers,...this.providerOverridesByModule.get(e)||[]];this.hasProviderOverrides(s)&&(this.maybeStoreNgDef(n.\u0275NG_INJ_DEF,e),this.storeFieldOfDefOnType(e,n.\u0275NG_INJ_DEF,"providers"),t.providers=this.getOverriddenProviders(s));const i=g(e[n.\u0275NG_MOD_DEF].imports);for(const l of i)this.applyProviderOverridesToModule(l);for(const l of _(t.imports))Q(l)&&(this.defCleanupOps.push({object:l,fieldName:"providers",originalValue:l.providers}),l.providers=this.getOverriddenProviders(l.providers))}}patchComponentsWithExistingStyles(){this.existingComponentStyles.forEach((e,t)=>t[n.\u0275NG_COMP_DEF].styles=e),this.existingComponentStyles.clear()}queueTypeArray(e,t){for(const s of e)Array.isArray(s)?this.queueTypeArray(s,t):this.queueType(s,t)}recompileNgModule(e,t){this.maybeStoreNgDef(n.\u0275NG_MOD_DEF,e),this.maybeStoreNgDef(n.\u0275NG_INJ_DEF,e),(0,n.\u0275compileNgModuleDefs)(e,t)}queueType(e,t){return this.resolvers.component.resolve(e)?((S(e)||!e.hasOwnProperty(n.\u0275NG_COMP_DEF))&&this.pendingComponents.add(e),this.seenComponents.add(e),void((!this.componentToModuleScope.has(e)||this.componentToModuleScope.get(e)===p.DECLARATION)&&this.componentToModuleScope.set(e,t))):this.resolvers.directive.resolve(e)?(e.hasOwnProperty(n.\u0275NG_DIR_DEF)||this.pendingDirectives.add(e),void this.seenDirectives.add(e)):void(!this.resolvers.pipe.resolve(e)||e.hasOwnProperty(n.\u0275NG_PIPE_DEF)||this.pendingPipes.add(e))}queueTypesFromModulesArray(e){const t=new Set,s=r=>{for(const i of r)if(Array.isArray(i))s(i);else if(B(i)){const l=i.\u0275mod;if(t.has(l))continue;t.add(l),this.queueTypeArray(g(l.declarations),i),s(g(l.imports)),s(g(l.exports))}else Q(i)&&s([i.ngModule])};s(e)}collectModulesAffectedByOverrides(e){const t=new Set,s=new Set,r=(i,l)=>{for(const c of i)if(Array.isArray(c))r(c,l);else if(B(c)){if(t.has(c)){s.has(c)&&l.forEach(f=>s.add(f));continue}t.add(c),this.overriddenModules.has(c)&&l.forEach(f=>s.add(f)),r(g(c[n.\u0275NG_MOD_DEF].imports),l.concat(c))}};return r(e,[]),s}maybeStoreNgDef(e,t){if(!this.initialNgDefs.has(t)){const s=Object.getOwnPropertyDescriptor(t,e);this.initialNgDefs.set(t,[e,s])}}storeFieldOfDefOnType(e,t,s){const r=e[t];this.defCleanupOps.push({object:r,fieldName:s,originalValue:r[s]})}clearComponentResolutionQueue(){null===this.originalComponentResolutionQueue&&(this.originalComponentResolutionQueue=new Map),U().forEach((e,t)=>this.originalComponentResolutionQueue.set(t,e))}restoreComponentResolutionQueue(){null!==this.originalComponentResolutionQueue&&(function ce(o){y.clear(),o.forEach((e,t)=>y.add(t)),m=o}(this.originalComponentResolutionQueue),this.originalComponentResolutionQueue=null)}restoreOriginalState(){V(this.defCleanupOps,e=>{e.object[e.fieldName]=e.originalValue}),this.initialNgDefs.forEach((e,t)=>{const[s,r]=e;r?Object.defineProperty(t,s,r):delete t[s]}),this.initialNgDefs.clear(),this.moduleProvidersOverridden.clear(),this.restoreComponentResolutionQueue(),(0,n.\u0275setLocaleId)(n.\u0275DEFAULT_LOCALE_ID)}compileTestModule(){class e{}(0,n.\u0275compileNgModuleDefs)(e,{providers:[...this.rootProviderOverrides]});const t=new n.NgZone({enableLongStackTrace:!0}),s=[{provide:n.NgZone,useValue:t},{provide:n.Compiler,useFactory:()=>new De(this)},...this.providers,...this.providerOverrides];(0,n.\u0275compileNgModuleDefs)(this.testModuleType,{declarations:this.declarations,imports:[e,this.additionalModuleTypes,this.imports||[]],schemas:this.schemas,providers:s},!0),this.applyProviderOverridesToModule(this.testModuleType)}get injector(){if(null!==this._injector)return this._injector;const e=[];this.platform.injector.get(n.COMPILER_OPTIONS).forEach(i=>{i.providers&&e.push(i.providers)}),null!==this.compilerProviders&&e.push(...this.compilerProviders);class s{}(0,n.\u0275compileNgModuleDefs)(s,{providers:e});const r=new n.\u0275NgModuleFactory(s);return this._injector=r.create(this.platform.injector).injector,this._injector}getSingleProviderOverrides(e){const t=Z(e);return this.providerOverridesByToken.get(t)||null}getProviderOverrides(e){return e&&e.length&&0!==this.providerOverridesByToken.size?_(_(e,t=>this.getSingleProviderOverrides(t)||[])):[]}getOverriddenProviders(e){if(!e||!e.length||0===this.providerOverridesByToken.size)return[];const t=_(e),s=this.getProviderOverrides(t),r=[...t,...s],i=[],l=new Set;return V(r,c=>{const a=Z(c);this.providerOverridesByToken.has(a)?l.has(a)||(l.add(a),i.unshift({...c,multi:!1})):i.unshift(c)}),i}hasProviderOverrides(e){return this.getProviderOverrides(e).length>0}patchDefWithProviderOverrides(e,t){const s=e[t];if(s&&s.providersResolver){this.maybeStoreNgDef(t,e);const r=s.providersResolver,i=l=>this.getOverriddenProviders(l);this.storeFieldOfDefOnType(e,t,"providersResolver"),s.providersResolver=l=>r(l,i)}}}function B(o){return o.hasOwnProperty("\u0275mod")}function g(o){return o instanceof Function?o():o}function _(o,e){const t=[];return o.forEach(s=>{Array.isArray(s)?t.push(..._(s,e)):t.push(e?e(s):s)}),t}function Z(o){return function Te(o,e){return o&&"object"==typeof o&&o[e]}(o,"provide")||o}function Q(o){return o.hasOwnProperty("ngModule")}function V(o,e){for(let t=o.length-1;t>=0;t--)e(o[t],t)}function D(o,e){return new Error(`${o} class doesn't have @${e} decorator or is missing metadata.`)}class De{constructor(e){this.testBed=e}compileModuleSync(e){return this.testBed._compileNgModuleSync(e),new n.\u0275NgModuleFactory(e)}compileModuleAsync(e){var t=this;return w(function*(){return yield t.testBed._compileNgModuleAsync(e),new n.\u0275NgModuleFactory(e)})()}compileModuleAndAllComponentsSync(e){const t=this.compileModuleSync(e),s=this.testBed._getComponentFactories(e);return new n.ModuleWithComponentFactories(t,s)}compileModuleAndAllComponentsAsync(e){var t=this;return w(function*(){const s=yield t.compileModuleAsync(e),r=t.testBed._getComponentFactories(e);return new n.ModuleWithComponentFactories(s,r)})()}clearCache(){}clearCacheFor(e){}getModuleId(e){const t=this.testBed._getModuleResolver().resolve(e);return t&&t.id||void 0}}class N{insertRootElement(e){}removeAllRootElements(){}}const W=new n.InjectionToken("ComponentFixtureAutoDetect"),$=new n.InjectionToken("ComponentFixtureNoNgZone");let q,Ce=0;class d{constructor(){this.platform=null,this.ngModule=null,this._compiler=null,this._testModuleRef=null,this._activeFixtures=[],this._globalCompilationChecked=!1}static initTestEnvironment(e,t,s){const r=u();return r.initTestEnvironment(e,t,s),r}static resetTestEnvironment(){u().resetTestEnvironment()}static configureCompiler(e){return u().configureCompiler(e),d}static configureTestingModule(e){return u().configureTestingModule(e),d}static compileComponents(){return u().compileComponents()}static overrideModule(e,t){return u().overrideModule(e,t),d}static overrideComponent(e,t){return u().overrideComponent(e,t),d}static overrideDirective(e,t){return u().overrideDirective(e,t),d}static overridePipe(e,t){return u().overridePipe(e,t),d}static overrideTemplate(e,t){return u().overrideComponent(e,{set:{template:t,templateUrl:null}}),d}static overrideTemplateUsingTestingModule(e,t){return u().overrideTemplateUsingTestingModule(e,t),d}static overrideProvider(e,t){return u().overrideProvider(e,t),d}static inject(e,t,s){return u().inject(e,t,s)}static get(e,t=n.Injector.THROW_IF_NOT_FOUND,s=n.InjectFlags.Default){return u().inject(e,t,s)}static createComponent(e){return u().createComponent(e)}static resetTestingModule(){return u().resetTestingModule(),d}static shouldTearDownTestingModule(){return u().shouldTearDownTestingModule()}static tearDownTestingModule(){u().tearDownTestingModule()}initTestEnvironment(e,t,s){if(this.platform||this.ngModule)throw new Error("Cannot set base providers because it has already been called");d._environmentTeardownOptions="function"==typeof s?void 0:s?.teardown,this.platform=t,this.ngModule=e,this._compiler=new L(this.platform,this.ngModule)}resetTestEnvironment(){this.resetTestingModule(),this._compiler=null,this.platform=null,this.ngModule=null,d._environmentTeardownOptions=void 0}resetTestingModule(){this.checkGlobalCompilationFinished(),(0,n.\u0275resetCompiledComponents)(),null!==this._compiler&&this.compiler.restoreOriginalState(),this._compiler=new L(this.platform,this.ngModule);try{this.destroyActiveFixtures()}finally{try{this.shouldTearDownTestingModule()&&this.tearDownTestingModule()}finally{this._testModuleRef=null,this._instanceTeardownOptions=void 0}}}configureCompiler(e){if(null!=e.useJit)throw new Error("the Render3 compiler JiT mode is not configurable !");void 0!==e.providers&&this.compiler.setCompilerProviders(e.providers)}configureTestingModule(e){this.assertNotInstantiated("R3TestBed.configureTestingModule","configure the test module"),this.checkGlobalCompilationFinished(),this._instanceTeardownOptions=e.teardown,this.compiler.configureTestingModule(e)}compileComponents(){return this.compiler.compileComponents()}inject(e,t,s){if(e===d)return this;const r={},i=this.testModuleRef.injector.get(e,r,s);return i===r?this.compiler.injector.get(e,t,s):i}get(e,t=n.Injector.THROW_IF_NOT_FOUND,s=n.InjectFlags.Default){return this.inject(e,t,s)}execute(e,t,s){const r=e.map(i=>this.inject(i));return t.apply(s,r)}overrideModule(e,t){this.assertNotInstantiated("overrideModule","override module metadata"),this.compiler.overrideModule(e,t)}overrideComponent(e,t){this.assertNotInstantiated("overrideComponent","override component metadata"),this.compiler.overrideComponent(e,t)}overrideTemplateUsingTestingModule(e,t){this.assertNotInstantiated("R3TestBed.overrideTemplateUsingTestingModule","Cannot override template when the test module has already been instantiated"),this.compiler.overrideTemplateUsingTestingModule(e,t)}overrideDirective(e,t){this.assertNotInstantiated("overrideDirective","override directive metadata"),this.compiler.overrideDirective(e,t)}overridePipe(e,t){this.assertNotInstantiated("overridePipe","override pipe metadata"),this.compiler.overridePipe(e,t)}overrideProvider(e,t){this.assertNotInstantiated("overrideProvider","override provider"),this.compiler.overrideProvider(e,t)}createComponent(e){const t=this.inject(N),s="root"+Ce++;t.insertRootElement(s);const r=e.\u0275cmp;if(!r)throw new Error(`It looks like '${(0,n.\u0275stringify)(e)}' has not been IVY compiled - it has no '\u0275cmp' field`);const i=this.inject($,!1),l=this.inject(W,!1),c=i?null:this.inject(n.NgZone,null),a=new n.\u0275Render3ComponentFactory(r),f=()=>{const M=a.create(n.Injector.NULL,[],`#${s}`,this.testModuleRef);return new I(M,c,l)},b=c?c.run(f):f();return this._activeFixtures.push(b),b}get compiler(){if(null===this._compiler)throw new Error("Need to call TestBed.initTestEnvironment() first");return this._compiler}get testModuleRef(){return null===this._testModuleRef&&(this._testModuleRef=this.compiler.finalize()),this._testModuleRef}assertNotInstantiated(e,t){if(null!==this._testModuleRef)throw new Error(`Cannot ${t} when the test module has already been instantiated. Make sure you are not using \`inject\` before \`${e}\`.`)}checkGlobalCompilationFinished(){!this._globalCompilationChecked&&null===this._testModuleRef&&(0,n.\u0275flushModuleScopingQueueAsMuchAsPossible)(),this._globalCompilationChecked=!0}destroyActiveFixtures(){let e=0;if(this._activeFixtures.forEach(t=>{try{t.destroy()}catch(s){e++,console.error("Error during cleanup of component",{component:t.componentInstance,stacktrace:s})}}),this._activeFixtures=[],e>0&&this.shouldRethrowTeardownErrors())throw Error(`${e} ${1===e?"component":"components"} threw errors during cleanup`)}shouldRethrowTeardownErrors(){const e=this._instanceTeardownOptions,t=d._environmentTeardownOptions;return!e&&!t||(e?.rethrowErrors??t?.rethrowErrors??this.shouldTearDownTestingModule())}shouldTearDownTestingModule(){return this._instanceTeardownOptions?.destroyAfterEach??d._environmentTeardownOptions?.destroyAfterEach??!0}tearDownTestingModule(){if(null===this._testModuleRef)return;const e=this.inject(N);try{this._testModuleRef.destroy()}catch(t){if(this.shouldRethrowTeardownErrors())throw t;console.error("Error during cleanup of a testing module",{component:this._testModuleRef.instance,stacktrace:t})}finally{e.removeAllRootElements?.()}}}function u(){return q=q||new d}const F=d,C=u;function J(o,e){const t=C();return function(){return t.execute(o,e,this)}}class H{constructor(e){this._moduleDef=e}_addModule(){const e=this._moduleDef();e&&C().configureTestingModule(e)}inject(e,t){const s=this;return function(){return s._addModule(),J(e,t).call(this)}}}function Re(o,e){return e?function(){const t=C();return o&&t.configureTestingModule(o),e.apply(this)}:new H(()=>o)}typeof window>"u"?global:window;const be=""}}]);